"use strict";(self.webpackChunkcontrast_dev=self.webpackChunkcontrast_dev||[]).push([[5702],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(n),h=l,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(m,a(a({ref:t},c),{},{components:n})):r.createElement(m,a({ref:t},c))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,a=new Array(i);a[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,a[1]=o;for(var u=2;u<i;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6876:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return u},assets:function(){return c},toc:function(){return p},default:function(){return h}});var r=n(7462),l=n(3366),i=(n(7294),n(3905)),a=["components"],o={slug:"CTF Write-Up",title:"Capture the Flag, Solution Write-Up",authors:["schaal"],tags:["research"]},s=void 0,u={permalink:"/blog/CTF Write-Up",editUrl:"https://github.com/erikcostlow/contrast-dev-site/edit/main/website/blog/blog/2021-10-07.md",source:"@site/blog/2021-10-07.md",title:"Capture the Flag, Solution Write-Up",description:"Contrast Labs is our security research team, writing the rules that power Contrast's suite of tools. A lot of our research starts with vulnerability analysis, reading and understanding how different exploits work at an API level and how we can detect that: during code analysis with Contrast Scan or as the application runs with Contrast Assess.",date:"2021-10-07T00:00:00.000Z",formattedDate:"October 7, 2021",tags:[{label:"research",permalink:"/blog/tags/research"}],readingTime:4.195,truncated:!1,authors:[{name:"Adam Schaal",title:"Security Research",imageURL:"https://github.com/clevernyyyy.png",key:"schaal"}],nextItem:{title:"Securing and Exploiting Java Applications",permalink:"/blog/Bangladesh JUG"}},c={authorsImageUrls:[void 0]},p=[{value:"Challenge Description",id:"challenge-description",children:[{value:"Maths",id:"maths",children:[]},{value:"Finding H(x)",id:"finding-hx",children:[]},{value:"Finding H(x<sub>2</sub>)<sup>-1</sup>",id:"finding-hx2-1",children:[]},{value:"Putting it all together",id:"putting-it-all-together",children:[]}]}],d={toc:p};function h(e){var t=e.components,n=(0,l.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Contrast Labs is our security research team, writing the rules that power Contrast's suite of tools. A lot of our research starts with vulnerability analysis, reading and understanding how different exploits work at an API level and how we can detect that: during code analysis with Contrast Scan or as the application runs with Contrast Assess."),(0,i.kt)("p",null,"To fully understand these exploits, our team frequently participates in Capture the Flag competitions to learn new styles of attacking applications. While we place well in many of the competitions, the real benefit is the team working together to play a game and the ability for new team members early in their career to rapidly improve their skills while having fun. We hire across a range of skills, but a common characteristic of every team member is the ability to work well together and help each-other."),(0,i.kt)("p",null,'We recently participated in the Cybrics CTF and performed a write-up of how our team solved one of the challenges to find a vulnerability in a message commit system. Here is the solution to the "Too Secure" problem:'),(0,i.kt)("h2",{id:"challenge-description"},"Challenge Description"),(0,i.kt)("p",null,"Find a vulnerability in our novel message commitment system. Read the paper here: ",(0,i.kt)("a",{href:"https://cybrics.net/files/too_secure.pdf",target:"_blank",download:"./too_secure.pdf"},"too_secure.pdf")),(0,i.kt)("p",null,"Enter decimal r2 value as the flag. Flag format here is NOT cybrics{...}"),(0,i.kt)("h3",{id:"maths"},"Maths"),(0,i.kt)("br",null),"Let H(x) be the function that generates \xe2 given x",(0,i.kt)("br",null),"Let x",(0,i.kt)("sub",null,"1"),", x",(0,i.kt)("sub",null,"2")," be the integer representations of M",(0,i.kt)("sub",null,"1")," and M",(0,i.kt)("sub",null,"2"),", respectively.",(0,i.kt)("br",null),"We're given",(0,i.kt)("br",null),"c = G * h ",(0,i.kt)("sup",null,"r"),(0,i.kt)("br",null),"Where G = g",(0,i.kt)("sup",null,"x")," mod p and h = g ^ H(x) mod p",(0,i.kt)("br",null),"We can combine and simplify:",(0,i.kt)("br",null),"c = g",(0,i.kt)("sup",null,"x + H(x)*r")," mod p",(0,i.kt)("br",null),(0,i.kt)("br",null),"To break the system, we want to find r",(0,i.kt)("sub",null,"2")," such that",(0,i.kt)("br",null),"c",(0,i.kt)("sub",null,"1")," = c",(0,i.kt)("sub",null,"2")," mod p",(0,i.kt)("br",null),"g",(0,i.kt)("sup",null,"x",(0,i.kt)("sub",null,"1")," + H(x",(0,i.kt)("sub",null,"1"),")*r",(0,i.kt)("sub",null,"1"))," = g",(0,i.kt)("sup",null,"x",(0,i.kt)("sub",null,"2")," + H(x",(0,i.kt)("sub",null,"2"),")*r",(0,i.kt)("sub",null,"2")),"mod p",(0,i.kt)("br",null),"Since g is known, and we're given that the O",(0,i.kt)("sub",null,"p"),"(g) = q, we could solve the above by solving:",(0,i.kt)("br",null),"x",(0,i.kt)("sub",null,"1")," + H(x",(0,i.kt)("sub",null,"1"),")*r",(0,i.kt)("sub",null,"1")," = x",(0,i.kt)("sub",null,"2")," + H(x",(0,i.kt)("sub",null,"2"),")*r",(0,i.kt)("sub",null,"2")," mod q",(0,i.kt)("br",null),"r2 = (x",(0,i.kt)("sub",null,"1")," - x",(0,i.kt)("sub",null,"2")," + H(x",(0,i.kt)("sub",null,"1"),")*r",(0,i.kt)("sub",null,"1"),") * H(x",(0,i.kt)("sub",null,"2"),")",(0,i.kt)("sup",null,"-1")," mod q",(0,i.kt)("br",null),"Where H(x",(0,i.kt)("sub",null,"2"),")",(0,i.kt)("sup",null,"-1")," is the multiplicative inverse of H(x",(0,i.kt)("sub",null,"2"),") modulo q ### Finding q",(0,i.kt)("br",null),"We were given q | (p-1), g",(0,i.kt)("sup",null,"q")," = 1 mod p. Luckily, factoring p-1 was pretty quick via some online factorization calculators",(0,i.kt)("br",null),"https://www.dcode.fr/prime-factors-decomposition",(0,i.kt)("br",null),"We test each prime factor against g and p.",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'g = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725\nqs = [2, 3, 7, 3671, 10733, 1039300813886545966418005631983853921163721828798787466771912919828750891]\np = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223\nq = 0\nfor q_ in qs:\n    v = pow(g, q_, p)\n    if v == 1:\n        q = q_\n\nprint("q", q)\n\n>>> q 1039300813886545966418005631983853921163721828798787466771912919828750891\n')),(0,i.kt)("h3",{id:"finding-hx"},"Finding H(x)"),(0,i.kt)("br",null),"Computing H(x) (called HAT(x) in the code below) was a little convoluted given the instructions:",(0,i.kt)("br",null),"Note: since p is prime, totient(p) = p-1",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'def str2val(message):\n  val = 0\n  mult = 1\n  for let in message:\n    val += ord(let) * mult\n    mult *= 256\n  return val\n\ndef chunkstring(string, length):\n    return (string[0+i:length+i] for i in range(0, len(string), length))\n\ndef bitstring_to_bytes(s):\n    b = bytearray()\n    chunks = chunkstring(s, 8)\n    for chunk in chunks:\n        num = int(chunk, 2)\n        b.append(num & 0xff)\n    return bytes(b)\n\ndef HAT(x):\n  G = pow(g, x, p)\n  numStr = "{0:b}".format(G)\n  if len(numStr) < 1024:\n      numStr = "0" * (1024 - len(numStr)) + numStr\n\n  Gp = bitstring_to_bytes(numStr)\n  a = hashlib.sha512(Gp).hexdigest()\n  ap = int(a, 16)\n  app = pow(ap, ap, p-1)\n  return app\n\nr1 = 31245182471\nM1 = "Hi! I am Vadim Davydov from ITMO University"\nx1 = str2val(M1)\nM2 = "Transfer the points for easy task to this team"\nx2 = str2val(M2)\n\nhat_x1 = HAT(x1)\nhat_x2 = HAT(x2)\n')),(0,i.kt)("h3",{id:"finding-hx2-1"},"Finding H(x",(0,i.kt)("sub",null,"2"),")",(0,i.kt)("sup",null,"-1")),(0,i.kt)("p",null,"Since q is prime, H(x",(0,i.kt)("sub",null,"2"),") and q are coprime, so we can use the Extended Euclidean Algorithm to find H(x",(0,i.kt)("sub",null,"2"),")",(0,i.kt)("sup",null,"-1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'def modulo_multiplicative_inverse(A, M):\n    """\n    Assumes that A and M are co-prime\n    Returns multiplicative modulo inverse of A under M\n    """\n    # Find gcd using Extended Euclid\'s Algorithm\n    gcd, x, y = extended_euclid_gcd(A, M)\n\n    # In case x is negative, we handle it by adding extra M\n    # Because we know that multiplicative inverse of A in range M lies\n    # in the range [0, M-1]\n    if x < 0:\n        x += M\n\n    return x\n\n\ndef extended_euclid_gcd(a, b):\n    """\n    Returns a list `result` of size 3 where:\n    Referring to the equation ax + by = gcd(a, b)\n        result[0] is gcd(a, b)\n        result[1] is x\n        result[2] is y\n    """\n    s = 0;\n    old_s = 1\n    t = 1;\n    old_t = 0\n    r = b;\n    old_r = a\n\n    while r != 0:\n        quotient = old_r // r  # In Python, // operator performs integer or floored division\n        # This is a pythonic way to swap numbers\n        # See the same part in C++ implementation below to know more\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n    return [old_r, old_s, old_t]\n\n\ninv = modulo_multiplicative_inverse(hat_x2, q)\n')),(0,i.kt)("h3",{id:"putting-it-all-together"},"Putting it all together"),(0,i.kt)("br",null),"r2 = (x",(0,i.kt)("sub",null,"1")," - x",(0,i.kt)("sub",null,"2")," + H(x",(0,i.kt)("sub",null,"1"),")*r",(0,i.kt)("sub",null,"1"),") * H(x",(0,i.kt)("sub",null,"2"),")",(0,i.kt)("sup",null,"-1")," mod q",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"print ( ((x1 - x2 + hat_x1 * r1) * inv ) % q )\n\n>>> 299610740605778098196154877327490870095375317123548563579894088319476495\n")))}h.isMDXComponent=!0}}]);